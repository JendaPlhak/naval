\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[czech]{babel}
\usepackage{a4wide}
\usepackage{amsmath, amsthm, amsfonts, amssymb, graphicx, url, fancyhdr,multicol,enumerate,titling}
\usepackage{algpseudocode}
\usepackage[]{algorithm2e}
\usepackage{listings}
\theoremstyle{plain}
\newtheorem{thm}{Theorem} %[section]
\newtheorem{lemma}[thm]{Lemma}

\lstdefinelanguage{algpseudocode}{
  keywordstyle=[1]{\keywordstyle},
  keywordstyle=[2]{\operatorstyle},
  keywordstyle=[3]{\typestyle},
  keywordstyle=[4]{\functionstyle},
  identifierstyle={\identifierstyle},
  keywords=[1]{%
    begin,end,%
    program,procedure,function,subroutine,%
    while,do,for,to,next,repeat,until,loop,continue,endwhile,endfor,endloop,%
    if,then,else,endif,%
    return},
  literate={-}{$-$}1 {^}{$^\wedge$}1
           {>}{{$>$\ }}1 {<}{{$<$\ }}1
           {>=}{{$\geqslant$\ }}1 {<=}{{$\leqslant$\ }}1
           {:=}{{$\gets$\ }}1 {!=}{{$\ne$\ }}1 {<>}{{$\ne$\ }}1
           {->}{{$\;\to\;$}}1
           {&&}{{\keywordstyle and\ }}4 {{||}}{{\keywordstyle or\ }}3
           {;}{\hspace{0.2em};}2 {,}{\hspace{0.2em},}2,
}

\lstset{%
  language={algpseudocode},
  columns=fullflexible,
  numbers=left,
  numberstyle=\scriptsize,
}

\newcommand\keywordstyle{\rmfamily\bfseries\upshape}
\newcommand\operatorstyle{\rmfamily\mdseries\upshape}
\newcommand\typestyle{\rmfamily\mdseries\upshape}
\newcommand\functionstyle{\rmfamily\mdseries\scshape}

\newcommand\identifierstyle{\rmfamily\mdseries\itshape}

\newcommand\addkeywords[1]{%
  \lstset{morekeywords=[1]{#1}}}

\newcommand\addoperators[1]{%
  \lstset{morekeywords=[2]{#1}}}

\newcommand\addtypes[1]{%
  \lstset{morekeywords=[3]{#1}}}

\newcommand\addfunctions[1]{%
  \lstset{morekeywords=[4]{#1}}}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\It}{\operatorname{It}}
\newcommand{\ord}{\operatorname{ord}}

\begin{document}
\pagestyle{fancy}                      %Pro větší­ možnosti práce se záhlaví­mi a zápatími
\fancyhf{}                             %"vyčištění záhlaví a zápatí"
%\renewcommand{\headheight}{25 pt}                  %
\addtolength{\topmargin}{-30 pt}                   %
\setlength{\headsep}{10 pt}                      %
\fancyhead[L]{{\emph{IV003 - sada 2, příklad 4}}}  %
\fancyhead[R]{{\emph{Jan Plhák (UČO 408420), Vladimír Sedláček (UČO 408178)}}}                  % Nastavení­ pro titulní­ stranu
%\fancyfoot[L]{Školní rok 2009/2010}                %
%\renewcommand{\footrulewidth}{0.8 pt}              %
\renewcommand{\headrulewidth}{1 pt}                %               %

\addfunctions{min_path}

První pozorování, které můžeme v případě čtvrtého příkladu učinit, je skutečnost, že pokud máme nějaký vrchol daného stromu T, tak abychom jej obsloužili na co nejmenší počet iterací stačí uspořádat jeho syny podle toho, kolik který z nich potřebuje iterací na to, aby byl celý jeho podstrom obsloužen a následně posílat synům zprávy v tomto pořadí. Skutečně - předpokládejme, že pro nějaké dva syny $ v, w$  platí $ \operatorname{ord}(v) < \operatorname{ord}(w) $ a zároveň $ \It(v) < \It(w) $, kde $ \operatorname{ord} $ značí pořadové číslo iterace, ve které jsme do daného uzlu poslali zprávu a $ \It $ značí počet iterací nezbytných k obsloužení daného syna. Pak ale prohozením pořadí, tedy zasláním zprávý prvně do náročnějšího vrcholu $ w $, a až pak do jednoduššího vrcholu $ v $, může celkový počet iterací zůstat buďto stejný nebo se zmenší, neboť iterace po které budou oba podstromy $ v $ a $ w $ obslouženy bude nyní $ it\_complete(v, w) = \min\{it\_complete(v), it\_complete(w) \} $, přičemž ale iterace ve které bude obsloužen podstrom $ v $ bude menší než před změnou pořadí iterace obsloužení podstromu $ w $ a samozřejmě také iterace ve které bude obsloužen podstrom $ w $ v novém pořadí se nemůže zvětšit, neboť do něj posíláme zprávu dříve. Proto Jakékoliv jiné pořadí než naše uspořádání bude stejně dobré, nebo horší.


Pro každý vrchol $ v $ tedy potřebujeme znát hodnotu funkce $ \It $. Pro $ v $ je list bude zřejmě platit $ \It(v) = 0 $. Jinak definujeme $ \It(v) = \max\limits_{u \in children(v)}\{\It(u)\} + \operatorname{extra}(v) + 1$, kde funkci $ \operatorname{extra} $ popisuje následující pseudokód.

\begin{lstlisting}[mathescape]
function $ \operatorname{extra} $(v)
  iterations := $ \{ \It(u) \mid u \in children(v) \}$ sorted descending 
  extra := 0 
  buffer := 0 
  for $i=2,\dots,|iterations| $ 
    buffer $\mathrel{+}= iterations[i - 1] - iterations[i]$
    if buffer = 0:
      extra $\mathrel{+}= 1 $
    else:
      buffer $\mathrel{-}= 1 $
  return extra
\end{lstlisting}

Vzhledem k výše uvedenému pozorování chceme tuto hodnotu efektivně spočítat pro každý vrchol. S využitím principů dynamického programování se dá nahlédnout, že abychom nic nemuseli počítat dvakrát, tak stačí daný strom procházet tak, abychom vždy nejprve vypočítali hodnoty $ \It $ pro všechny syny a až pak počítali jejich otce. Takovýmto procházením může být například procházení do hloubky a navštěvování vrcholů post-order. Proto algoritmus, který efektivně spočítá $ \It $ pro všechny vrcholy stromu $ T $  může vypadat například takto:

\begin{lstlisting}[mathescape]
function $ \operatorname{compute\_it} $(T)
  for v in {Vertices of T in $\textit{post-order}$}
    if v is leaf:
      $\It(v) $ = 0
    else:
      $ \It(v) = \max\limits_{u \in children(v)}\{\It(u)\} + \operatorname{extra}(v) + 1$
\end{lstlisting}

V každém vrcholu tím máme k dispozici počet iterací nezbytný pro obsloužení každého ze synů. Zprávy pak budeme synům posílat v sestupném uspořádání synů podle počtu nezbytných iterací.

Z konečnosti prohledávání do hloubky a nepřítomnosti rekurze vyplývá, že uvedený algoritmus bude vždy konečný. K důkazu korektnosti proto stačí ukázat, že způsob, jakým počítáme $ \It(u) $ je korektní. Pokud je $ u $ list, pak je tvrzení zřejmé. Předpokládejme tedy, že $ u $ není list. Pokud má $ u $ jen jednoho potomka, pak formule funguje bezvadně neboť budeme potřebovat jednu iteraci na zaslání zprávy potomkovi + $ \It(child(u)) $ iterací na vyřízení potomka. Předpokládejme proto, že formule funguje pokud má $ u $ nejvýše $ n $ potomků a ukážeme, že pak musí fungovat také pokud jich má $ n + 1 $. 

Nechť má tedy $ |children(u)| = n+1 $ a mějme $ x \in children(u) $, takový, že $ \It(x) = \min\limits_{y \in children(u)}\{\It(y)\} $. Dále označme $ k $ hodnotu funkce $ It(u) $, pokud bychom potomka $ x $ při výpočtu zcela ignorovali. Díky indukčnímu předpokladu tím získáme minimální počet iterací, který musíme vykonat aby se zprávy dostaly ke všem potomkům výjma $ x $. Zřejmě na hodnotu maxima počítaného maxima nemá nepřítomnost prvku $ x $ žádný vliv, přičtení jedničky je konstantní a tak jedině výpočet funkce $ extra(u) $ se může nějakým způsobem lišit. Zkoumejme tedy, jaký vliv má vrchol $ x $ na její hodnotu.  

Ty poslední dva odstavce asi nejsou moc dobře, musel jsem pak ještě předělat tu funkci extra, tak to bude chtít asi upravit :-/
\end{document}
